{
  "language": "Solidity",
  "sources": {
    "contracts/Treasury.sol": {
      "content": "//SPDX-License-Identifier: UNLICENSED\n\npragma solidity >= 0.6.0 <0.7.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n//import \"./Shoal.sol\";\n//import \"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/payment/PaymentSplitter.sol\";\n\n// todo make ownable\ncontract Treasury {\n    using SafeMath for uint;\n\n    event DepositEvent(uint _amount, address _from, uint when);\n\n    event WithdrawalEvent(uint _amount, uint _amountRemaining, address _to, uint when);\n\n    event DepositWithdrawnEvent(uint _amount, address _to, uint when, bool isDepositEmpty);\n\n    modifier withdrawalLimit(uint _amount, address _address) {\n        require(addressBalances[_address] >= _amount, \"Total withdrawal exceeds total deposited\");\n        _;\n    }\n\n    struct DepositStruct {\n        uint _amount;\n        address _address;\n        uint _timeDeposit;\n    }\n\n    mapping(address => DepositStruct[]) public deposits;\n\n    mapping(address => uint) public addressBalances;\n\n//    Shoal private shoal;\n//\n//    constructor(Shoal _shoal) public {\n//        shoal = _shoal;\n//    }\n\n    receive() payable external {\n        deposit(msg.sender);\n    }\n\n    function deposit(address _address) payable public {\n        uint timeDeposit = block.timestamp * 14;\n        deposits[_address].push(\n            DepositStruct(\n                msg.value,\n                _address,\n                timeDeposit\n            )\n        );\n\n        addressBalances[_address] = addressBalances[_address].add(msg.value);\n\n        emit DepositEvent(msg.value, _address, timeDeposit);\n    }\n\n    function getDepositsForAddress(address _address) public view returns (uint amount) {\n        require(deposits[_address].length > 0, \"No deposits\");\n        uint totalDeposited = 0;\n\n        for (uint i = 0; i < deposits[_address].length; i++) {\n            uint amountInDeposit = deposits[_address][i]._amount;\n            totalDeposited = totalDeposited.add(amountInDeposit);\n        }\n\n        return totalDeposited;\n    }\n\n    // Remember checks effects interaction\n    function withdraw(address payable _address, uint _amount) external withdrawalLimit(_amount, _address) {\n        handleFundBalancing(_address, _amount);\n        addressBalances[_address] = addressBalances[_address].sub(_amount);\n\n        emit WithdrawalEvent(_amount, addressBalances[_address], _address, block.timestamp * 14);\n\n        _address.transfer(_amount);\n    }\n\n    // Could use a refactor\n    function handleFundBalancing(address payable _address, uint _amountToWithdraw) internal {\n        uint amountLeftToWithdraw = _amountToWithdraw;\n        uint when = block.timestamp * 14;\n\n        // Grab each deposit for address\n        for (uint i = 0; i < deposits[_address].length; i++) {\n            // Get amount in the deposit\n            uint amountInDeposit = deposits[_address][i]._amount;\n\n            // If the total amount in the deposit is equal or greater than the amount to withdraw we calculate the amount remaining\n            if (amountInDeposit >= amountLeftToWithdraw) {\n                uint remainder = amountInDeposit.sub(amountLeftToWithdraw);\n\n                // If there is a remainder update the deposit\n                if (remainder > 0) {\n                    emit DepositWithdrawnEvent(amountLeftToWithdraw, _address, when, false);\n                    deposits[_address][i]._amount = remainder;\n                } else {\n                    emit DepositWithdrawnEvent(amountLeftToWithdraw, _address, when, true);\n                    delete deposits[_address][i];\n                }\n                break;\n            }\n\n            // Subtract the amount in the deposit from the amount to withdraw\n            amountLeftToWithdraw = amountLeftToWithdraw.sub(amountInDeposit);\n            emit DepositWithdrawnEvent(amountInDeposit, _address, when, true);\n            delete deposits[_address][i];\n        }\n    }\n}"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}